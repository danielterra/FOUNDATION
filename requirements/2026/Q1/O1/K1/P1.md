## Problem 1: Database Technology Selection

### What
We don't know which database technology to use for SuperNOVA's immutable, reactive data model that needs to:
- Work across desktop platforms (Linux, Windows, macOS)
- Support immutable data patterns (append-only, no updates/deletes)
- Expose changes as observable events (for reactive actions)
- Provide good performance for user-facing operations (<100ms for common queries)
- Be embeddable (no separate server process)
- Support efficient export/import of data subsets (foundation for sync layer)

### Why
The database is foundational to achieving KR1. Users need to record 20+ transactions quickly (<30 minutes), which requires:
- Fast data entry and retrieval
- Reliable local storage
- Observable changes (for reactive features in KR2)

Choosing the wrong technology could:
- Block cross-platform development
- Make immutability and reactivity difficult to implement
- Create performance bottlenecks
- Force a costly rewrite later

### How (Hypotheses)

#### Option 1: SurrealDB (with RocksDB backend) ⭐ RECOMMENDED
**Pros:**
- **Native change observability** - Live Queries + Change Feeds (perfect for reactive architecture)
- Cross-platform (Linux, Windows, macOS, and future iOS support)
- Embeddable in Rust applications
- Multi-model flexibility (document, graph, key-value)
- Versioning support via SurrealKV (time-travel queries when mature)
- Pure Rust (memory safe, good FFI)

**Cons:**
- Younger project (v2.0 recently released, moderate risk)
- SurrealKV still evolving (use RocksDB backend initially)
- Must implement immutability at application level
- Larger footprint than pure key-value stores

**Performance:** Meets all requirements (<1s for 100 inserts, <50ms queries)

#### Option 2: redb + Custom Observability Layer
**Pros:**
- Stable 1.0 release with file format guarantees
- **Excellent individual write performance** (920ms for 100 records)
- Pure Rust (memory safe, no C++ dependencies)
- Small footprint, clean codebase
- ACID transactions with MVCC
- Only 9 open issues (very stable)

**Cons:**
- **No built-in change observability** (must implement observer pattern manually)
- Key-value only (must build data model on top)
- Must implement immutability patterns at application level
- Slower batch writes vs LSM trees

**Performance:** Best for individual transaction inserts

#### Option 3: RocksDB (via rust-rocksdb)
**Pros:**
- Battle-tested at massive scale (Facebook, Apple, FoundationDB)
- **Excellent batch write performance** (451ms)
- Transaction Log Iterator for change tracking
- EventListener API for monitoring
- Rich tuning options

**Cons:**
- C++ dependency (slower builds, external dependencies)
- Change observability less elegant than SurrealDB
- Requires significant tuning for optimal performance
- Higher memory usage during compaction

**Performance:** Best for bulk operations

#### Option 4: SQLite + Event Store Pattern (Conservative baseline)
**Pros:**
- Universal platform support (25+ years of stability)
- Most deployed database in the world
- Excellent tooling ecosystem
- Well-understood technology

**Cons:**
- **Poor change observability** (requires polling or complex triggers)
- Must implement event store pattern manually
- Not designed for reactive architectures
- Schema migrations can be painful

**Performance:** Good enough, but not optimized for reactivity

### Success Criteria

The chosen database technology must demonstrate:

1. **Cross-platform viability** - Works on Linux, Windows, and macOS
2. **Immutability support** - Can enforce append-only operations efficiently
3. **Performance baseline** - Can handle:
   - Insert 100 transaction records in <1 second
   - Query current state (20 transactions) in <50ms
   - Query history (100 records) in <200ms
4. **Change observability** - Can efficiently notify when data changes (for reactive actions)
5. **Export/Import** - Can efficiently export subsets of data (for sync layer to use)
6. **Development speed** - Doesn't block rapid prototyping for Q1 goals

### Validation Plan

1. **Research phase** (3 days) ✅ COMPLETE
   - Comprehensive evaluation of embedded databases
   - SurrealDB identified as best fit for reactive architecture
   - redb as stable fallback option
   - Performance benchmarks reviewed

2. **Prototype phase** (5 days)
   - **Prototype A: SurrealDB** (2 days)
     - Implement basic Transaction entity with CRUD
     - Test Live Queries for change notifications
     - Verify cross-platform build (Linux, Windows, macOS)
     - Benchmark insert/query performance

   - **Prototype B: redb + Custom Observer** (2 days)
     - Implement basic Transaction entity with CRUD
     - Build simple observer pattern for change notifications
     - Verify cross-platform build
     - Benchmark insert/query performance

   - **Comparison** (1 day)
     - Developer experience (ease of implementation)
     - Performance (actual vs expected)
     - Code complexity (lines of code, maintainability)
     - Risk assessment (maturity, community, documentation)

3. **Decision** (1 day)
   - Select primary option based on prototype results
   - Document decision rationale and trade-offs
   - Create risk mitigation plan
   - Identify any blocking issues discovered

**Total time budget: 2 weeks maximum**

### Recommendation

Start prototyping with **SurrealDB** as Option 1 due to:
- Native change observability (critical for reactive architecture)
- Best alignment with SuperNOVA principles
- Cross-platform support including future mobile

Have **redb** ready as fallback if SurrealDB proves too immature or complex.

---

## ✅ DECISION (2025-11-25) - REVISED

**Selected: SQLite**

**Rationale:**

1. **Battle-tested Stability** - 25+ years of production use, most deployed database in the world, rock-solid reliability

2. **Zero Configuration** - Single file database, no server process, works everywhere out of the box

3. **Universal Support** - Native support on every platform (desktop, mobile, embedded), massive ecosystem

4. **Version Control Friendly** - Database file can be versioned in git, easily replicated/synced via rsync, git, or custom protocols

5. **Embeddable** - Runs in-process, no dependencies, minimal footprint (Principle 2: Autonomy)

6. **Ontology Storage** - Perfect for importing OWL/TTL ontologies (BFO, CCO) as initial versioned data

**Implementation Strategy:**
- Use SQLite with RDF triple store schema (subject-predicate-object)
- Import BFO and Common Core Ontologies at build time
- Implement change observability via triggers + event queue table
- Leverage SQLite's JSON support for flexible metadata
- Use WAL mode for better concurrent read performance

**Trade-offs Accepted:**
- Change observability requires custom implementation (triggers + polling)
- Must build reactive layer on top (acceptable - more control)
- No native graph queries (use recursive CTEs for traversal)

**Risk Mitigation:**
- SQLite is the most stable database choice possible
- Well-understood technology with decades of production use
- Trivial to backup, replicate, and version control
- Can optimize reactivity layer incrementally as needed

**Next Steps:**
1. Design RDF triple store schema for SQLite
2. Build OWL/TTL import tool to populate initial ontologies
3. Create versioned initial database with BFO + CCO
4. Implement change event system via triggers
5. Benchmark performance against success criteria
