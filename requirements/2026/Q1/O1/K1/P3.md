## Problem 3: RDF Triple Store Architecture

### What
We don't know how to structure data in SurrealDB to support SuperNOVA's architecture principles:

**Interoperability (Principle 3)**
- Data created in one SuperNOVA instance must work in another
- Why: Shared ontology enables instances to understand each other's data

**Class Extension & Inference (Principle 3)**
- Users extend base classes (Employee extends Person)
- System must infer inherited properties automatically
- Why: "SoftwareEngineer extends Person" should inherit all Person properties without configuration

**Immutable Timeline (Principle 5)**
- Never update records - only insert new facts that replace old ones
- Why: Complete history preserved for undo, audit, compliance

**Automation Reliability (Principle 4)**
- System must reliably detect and replay every data change
- Why: "Database itself is the log" - automations replay from change history

**Origin Tracking (Principle 6)**
- Every fact must track who/what asserted it (user, AI, import, automation)
- Why: Transparency and accountability for all data changes

**Multi-Source Truth**
- Different sources can assert conflicting facts simultaneously
- Why: User edits while AI suggests updates and imports run

**Relationship Navigation**
- Efficiently traverse entity relationships (Person → worksAt → Organization → locatedIn → City)
- Why: Query across connected entities like spreadsheet formulas but without breaking

---

### Solution: Immutable RDF Triple Store

**Core Architecture:**

Store all data as immutable triples (subject-predicate-object) with temporal tracking.

**Example: Personal Finance Management**

```
// Resources (entities)
transaction:tx001 → type: Transaction
category:food → type: Category
account:checking → type: BankAccount

// Data properties (literal values)
triple(subject: transaction:tx001, predicate: amount, object: "45.50",
       asserted_at: 2024-01-15, retracted_at: NULL, origin: user:alice)

triple(subject: transaction:tx001, predicate: description, object: "Grocery Store",
       asserted_at: 2024-01-15, retracted_at: NULL, origin: user:alice)

// Object properties (relationships/edges)
triple(subject: transaction:tx001, predicate: hasCategory, object: category:food,
       asserted_at: 2024-01-15, retracted_at: NULL, origin: user:alice)

triple(subject: transaction:tx001, predicate: fromAccount, object: account:checking,
       asserted_at: 2024-01-15, retracted_at: NULL, origin: user:alice)

// Later: User changes category (immutable - never UPDATE)
triple(subject: transaction:tx001, predicate: hasCategory, object: category:food,
       asserted_at: 2024-01-15, retracted_at: 2024-01-20, origin: user:alice)

triple(subject: transaction:tx001, predicate: hasCategory, object: category:restaurants,
       asserted_at: 2024-01-20, retracted_at: NULL, origin: user:alice)
```

**Graph traversal example:**

```sql
-- Find all transactions in "food" category from checking account
SELECT * FROM transaction:tx001
  ->triple[WHERE predicate = property:hasCategory]->object_resource
  WHERE id = category:food;

-- Calculate total spent by category
SELECT category, SUM(amount) FROM transaction
  ->triple[WHERE predicate = property:hasCategory]->object_resource AS category
  ->triple[WHERE predicate = property:amount]->object_literal AS amount
  GROUP BY category;
```

**How it solves each requirement:**

1. **Interoperability** → RDF standard [1] + Schema.org vocabulary [2]
   - All instances use same base ontology (Transaction, Category, Account)
   - Export/import as Turtle, JSON-LD

2. **Class Extension** → parent_class references + Schema.org types [2]
   - RecurringTransaction extends Transaction through parent_class link
   - Inherits amount, description, hasCategory properties

3. **Immutable Timeline** → Never UPDATE/DELETE, only INSERT
   - Category change creates new triple, marks old as retracted
   - Query historical state: "What category was tx001 on January 18?"

4. **Automation Reliability** → Append-only log is the source of truth
   - Scan triples for category changes since last run
   - Trigger budget alerts when food spending exceeds limit

5. **Origin Tracking** → Every triple has origin field
   - User manually sets category vs AI auto-categorizes vs bank import
   - Trust user > import > AI when conflicts occur

6. **Multi-Source Truth** → Multiple active triples for same property
   - User says "food", AI suggests "restaurants", bank import says "groceries"
   - All coexist; UI shows all sources and lets user choose

7. **Relationship Navigation** → SurrealDB graph queries [3]
   - Follow edges: Transaction → hasCategory → Category → parentCategory → Food
   - Multi-hop: Transaction → fromAccount → Account → belongsTo → Person

