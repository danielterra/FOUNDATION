## Problem 3: EAVTO Immutable Facts Architecture

### What
We don't know how to structure data in SQLite to support SuperNOVA's architecture principles:

**Interoperability (Principle 3)**
- Data created in one SuperNOVA instance must work in another
- Why: Shared ontology enables instances to understand each other's data

**Class Extension & Inference (Principle 3)**
- Users extend base classes (Employee extends Person)
- System must infer inherited properties automatically
- Why: "SoftwareEngineer extends Person" should inherit all Person properties without configuration

**Immutable Timeline (Principle 5)**
- Never update records - only insert new facts that replace old ones
- Why: Complete history preserved for undo, audit, compliance

**Automation Reliability (Principle 4)**
- System must reliably detect and replay every data change
- Why: "Database itself is the log" - automations replay from change history

**Origin Tracking (Principle 6)**
- Every fact must track who/what asserted it (user, AI, import, automation)
- Why: Transparency and accountability for all data changes

**Multi-Source Truth**
- Different sources can assert conflicting facts simultaneously
- Why: User edits while AI suggests updates and imports run

**Relationship Navigation**
- Efficiently traverse entity relationships (Person → worksAt → Organization → locatedIn → City)
- Why: Query across connected entities like spreadsheet formulas but without breaking

---

### Solution: EAVTO (Entity-Attribute-Value-Time-Origin) Architecture

**Core Architecture:**

Store all data as immutable facts using the EAVTO model:
- **E** (Entity) - The subject of the fact (e.g., `transaction:tx001`)
- **A** (Attribute) - The property/predicate (e.g., `amount`, `hasCategory`)
- **V** (Value) - The object literal or reference (e.g., `"45.50"`, `category:food`)
- **T** (Transaction) - Monotonically increasing transaction ID (logical timestamp)
- **O** (Origin) - Who/what asserted this fact (e.g., `user:alice`, `import:bank`, `core` for base ontology)

**Four Indices for Efficient Queries:**

We create four covering indices to optimize different query patterns:

1. **EAVTO** - Primary index, find all facts about an entity
2. **AEVTO** - Find all entities with a specific attribute
3. **AVETO** - Find entities by attribute-value pair (reverse lookup)
4. **VAETO** - Find all references to an entity (who points to this?)

**Special Origin: `core`**

The origin `core` is reserved for immutable base facts:
- Base ontology (BFO, Common Core Ontologies)
- System schema definitions
- Built-in types and properties
- These facts are never retracted and come pre-loaded in versioned database

**Example: Personal Finance Management**

```
// Base ontology facts (origin: core, never retracted)
fact(e: "owl:Class", a: "rdf:type", v: "owl:Class", tx: 1, origin: "core", retracted: false)
fact(e: "Transaction", a: "rdf:type", v: "owl:Class", tx: 1, origin: "core", retracted: false)
fact(e: "Category", a: "rdf:type", v: "owl:Class", tx: 1, origin: "core", retracted: false)
fact(e: "amount", a: "rdf:type", v: "owl:DatatypeProperty", tx: 1, origin: "core", retracted: false)
fact(e: "hasCategory", a: "rdf:type", v: "owl:ObjectProperty", tx: 1, origin: "core", retracted: false)

// User creates entities and data (tx: 100)
fact(e: "transaction:tx001", a: "rdf:type", v: "Transaction", tx: 100, origin: "user:alice", retracted: false)
fact(e: "transaction:tx001", a: "amount", v: "45.50", tx: 100, origin: "user:alice", retracted: false)
fact(e: "transaction:tx001", a: "description", v: "Grocery Store", tx: 100, origin: "user:alice", retracted: false)
fact(e: "transaction:tx001", a: "hasCategory", v: "category:food", tx: 100, origin: "user:alice", retracted: false)
fact(e: "transaction:tx001", a: "fromAccount", v: "account:checking", tx: 100, origin: "user:alice", retracted: false)

// Later: User changes category (tx: 150, immutable - never UPDATE)
fact(e: "transaction:tx001", a: "hasCategory", v: "category:food", tx: 100, origin: "user:alice", retracted: true)
fact(e: "transaction:tx001", a: "hasCategory", v: "category:restaurants", tx: 150, origin: "user:alice", retracted: false)

// AI suggests different category simultaneously (tx: 151, multi-source truth)
fact(e: "transaction:tx001", a: "hasCategory", v: "category:dining", tx: 151, origin: "ai:categorizer", retracted: false)
```

**Query Examples Using Four Indices:**

```sql
-- 1. EAVTO Index: Find all facts about transaction:tx001 (current state)
SELECT a, v FROM facts
WHERE e = 'transaction:tx001' AND retracted = 0
ORDER BY e, a, tx DESC;

-- 2. AEVTO Index: Find all transactions with amount property
SELECT e, v FROM facts
WHERE a = 'amount' AND retracted = 0
ORDER BY a, e, tx DESC;

-- 3. AVETO Index: Find all transactions in "food" category (reverse lookup)
SELECT e FROM facts
WHERE a = 'hasCategory' AND v = 'category:food' AND retracted = 0
ORDER BY a, v, e, tx DESC;

-- 4. VAETO Index: Find all entities that reference account:checking
SELECT e, a FROM facts
WHERE v = 'account:checking' AND retracted = 0 AND v_type = 'ref'
ORDER BY v, a, e, tx DESC;

-- Historical query: What was tx001's category on tx 120?
SELECT v FROM facts
WHERE e = 'transaction:tx001'
  AND a = 'hasCategory'
  AND tx <= 120
  AND retracted = 0
ORDER BY tx DESC LIMIT 1;

-- Multi-source truth: All current category suggestions for tx001
SELECT origin, v FROM facts
WHERE e = 'transaction:tx001'
  AND a = 'hasCategory'
  AND retracted = 0
ORDER BY tx DESC;
```

**How it solves each requirement:**

1. **Interoperability** → RDF-compatible + BFO/CCO ontologies
   - All instances use same base ontology from `core` origin
   - Export/import as Turtle, JSON-LD via EAVTO → RDF triple conversion
   - Standard vocabularies ensure cross-instance compatibility

2. **Class Extension** → rdfs:subClassOf stored as facts
   - `fact(e: "RecurringTransaction", a: "rdfs:subClassOf", v: "Transaction", tx: 1, origin: "core")`
   - Query inherited properties via recursive CTE traversal
   - Inference at query time using class hierarchy

3. **Immutable Timeline** → Never UPDATE/DELETE, only INSERT + retracted flag
   - Category change: mark old fact `retracted = 1`, insert new fact
   - Query historical state: filter by `tx <= N AND retracted = 0`
   - Complete audit trail preserved forever

4. **Automation Reliability** → Transaction log IS the database
   - Scan facts WHERE `tx > last_processed_tx` for incremental processing
   - Trigger actions when specific (E, A, V) patterns appear
   - Replay entire history by processing facts in tx order

5. **Origin Tracking** → Every fact has origin field
   - User edits: `origin: "user:alice"`
   - AI suggestions: `origin: "ai:categorizer"`
   - Bank imports: `origin: "import:bank_csv"`
   - Base ontology: `origin: "core"` (immutable, never retracted)
   - Trust hierarchies: prefer user > import > AI when resolving conflicts

6. **Multi-Source Truth** → Multiple non-retracted facts for same (E, A)
   - User, AI, and import can all assert different values simultaneously
   - All coexist with `retracted = 0`
   - UI shows all origins and lets user resolve or accept multiple truths
   - Queries can filter by origin: `WHERE origin LIKE 'user:%'`

7. **Relationship Navigation** → VAETO index + recursive CTEs
   - Forward: Use EAVTO to get all properties of an entity
   - Backward: Use VAETO to find "who points to this entity?"
   - Multi-hop traversal: Recursive CTE following object→entity chains
   - Example: `Transaction → fromAccount → Account → belongsTo → Person`

---

### SQLite Schema Design

**Hybrid Approach: Text + Typed Columns**

We use a hybrid storage strategy that combines the simplicity of text-based values with the performance of typed columns:

- **`v` (TEXT)** - Always stores the string representation (primary source of truth, used in indices)
- **Typed columns** - Optional columns for native numeric/temporal operations (performance optimization)

This approach provides:
- ✅ Simple text-based indices for exact lookups (EAVTO pattern)
- ✅ Native typed operations for range queries (`amount > 100`)
- ✅ Correct numeric/temporal sorting
- ✅ RDF export compatibility (use `v` text)

```sql
-- Main facts table (append-only, immutable)
CREATE TABLE facts (
  -- EAV core (always populated)
  e TEXT NOT NULL,          -- Entity ID
  a TEXT NOT NULL,          -- Attribute/Property ID
  v TEXT NOT NULL,          -- Value as text (primary source of truth)

  -- Typed columns (NULL if not applicable, for performance)
  v_number REAL,            -- Populated when v_type = 'number'
  v_integer INTEGER,        -- Populated when v_type = 'integer'
  v_datetime INTEGER,       -- Populated when v_type = 'datetime' (Unix epoch ms)

  -- Transaction metadata
  tx INTEGER NOT NULL,      -- Transaction ID (monotonic, logical timestamp)
  origin TEXT NOT NULL,     -- Who asserted this fact (user:id, ai:model, import:source, "core")
  retracted INTEGER NOT NULL DEFAULT 0,  -- 0 = active, 1 = retracted

  v_type TEXT NOT NULL CHECK(v_type IN ('string', 'number', 'integer', 'boolean', 'ref', 'datetime')),
  created_at INTEGER NOT NULL,  -- Physical timestamp (Unix epoch milliseconds)

  -- Consistency constraint: typed columns match v_type
  CHECK (
    (v_type = 'string') OR
    (v_type = 'number' AND v_number IS NOT NULL) OR
    (v_type = 'integer' AND v_integer IS NOT NULL) OR
    (v_type = 'boolean' AND v IN ('true', 'false', '0', '1')) OR
    (v_type = 'ref') OR
    (v_type = 'datetime' AND v_datetime IS NOT NULL)
  )
);

-- Index 1: EAVTO - Find all attributes/values for an entity (text-based)
CREATE INDEX idx_eavto ON facts(e, a, v, tx, origin);

-- Index 2: AEVTO - Find all entities with a specific attribute (text-based)
CREATE INDEX idx_aevto ON facts(a, e, v, tx, origin);

-- Index 3: AVETO - Find entities by attribute-value pair (text-based, reverse lookup)
CREATE INDEX idx_aveto ON facts(a, v, e, tx, origin);

-- Index 4: VAETO - Find all references to an entity (backlinks)
CREATE INDEX idx_vaeto ON facts(v, a, e, tx, origin) WHERE v_type = 'ref';

-- Performance indices for range queries on typed columns
CREATE INDEX idx_a_number ON facts(a, v_number, tx)
  WHERE v_type = 'number' AND retracted = 0;

CREATE INDEX idx_a_integer ON facts(a, v_integer, tx)
  WHERE v_type = 'integer' AND retracted = 0;

CREATE INDEX idx_a_datetime ON facts(a, v_datetime, tx)
  WHERE v_type = 'datetime' AND retracted = 0;

-- Transaction log (metadata about each transaction)
CREATE TABLE transactions (
  tx INTEGER PRIMARY KEY AUTOINCREMENT,  -- Transaction ID
  origin TEXT NOT NULL,                   -- Origin of this transaction batch
  created_at INTEGER NOT NULL             -- Physical timestamp
);

-- Fast transaction ID lookup
CREATE INDEX idx_tx ON transactions(tx DESC);
```

**Query Patterns:**

```sql
-- Exact value lookup (uses text index)
SELECT * FROM facts
WHERE a = 'amount'
  AND v = '45.50'
  AND retracted = 0;

-- Range query (uses typed index for performance)
SELECT e, v, v_number FROM facts
WHERE a = 'amount'
  AND v_number > 100.0
  AND retracted = 0
ORDER BY v_number DESC;

-- Temporal query (uses datetime index)
SELECT e, v FROM facts
WHERE a = 'createdAt'
  AND v_datetime >= 1732547890000
  AND v_datetime < 1732634290000
  AND retracted = 0;

-- Reference lookup (uses VAETO backlinks index)
SELECT e, a FROM facts
WHERE v = 'category:food'
  AND v_type = 'ref'
  AND retracted = 0;
```

**Insert Examples:**

```sql
-- String value
INSERT INTO facts (e, a, v, v_number, v_integer, v_datetime, tx, origin, retracted, v_type, created_at)
VALUES ('tx001', 'description', 'Grocery Store', NULL, NULL, NULL, 100, 'user:alice', 0, 'string', 1732547890000);

-- Numeric value (populate both v and v_number)
INSERT INTO facts (e, a, v, v_number, v_integer, v_datetime, tx, origin, retracted, v_type, created_at)
VALUES ('tx001', 'amount', '45.50', 45.50, NULL, NULL, 100, 'user:alice', 0, 'number', 1732547890000);

-- Integer value
INSERT INTO facts (e, a, v, v_number, v_integer, v_datetime, tx, origin, retracted, v_type, created_at)
VALUES ('tx001', 'quantity', '3', NULL, 3, NULL, 100, 'user:alice', 0, 'integer', 1732547890000);

-- Boolean value
INSERT INTO facts (e, a, v, v_number, v_integer, v_datetime, tx, origin, retracted, v_type, created_at)
VALUES ('tx001', 'isPaid', 'true', NULL, NULL, NULL, 100, 'user:alice', 0, 'boolean', 1732547890000);

-- Reference value
INSERT INTO facts (e, a, v, v_number, v_integer, v_datetime, tx, origin, retracted, v_type, created_at)
VALUES ('tx001', 'hasCategory', 'category:food', NULL, NULL, NULL, 100, 'user:alice', 0, 'ref', 1732547890000);

-- DateTime value (populate both v and v_datetime)
INSERT INTO facts (e, a, v, v_number, v_integer, v_datetime, tx, origin, retracted, v_type, created_at)
VALUES ('tx001', 'purchasedAt', '2024-11-25T15:30:00Z', NULL, NULL, 1732547890000, 100, 'user:alice', 0, 'datetime', 1732547890000);
```

**Retraction Mechanism:**

```sql
-- To "update" a fact, insert two rows in same transaction:
INSERT INTO facts (e, a, v, v_number, v_integer, v_datetime, tx, origin, retracted, v_type, created_at) VALUES
  -- Mark old value as retracted
  ('transaction:tx001', 'hasCategory', 'category:food', NULL, NULL, NULL, 100, 'user:alice', 1, 'ref', 1732547890000),
  -- Insert new value
  ('transaction:tx001', 'hasCategory', 'category:restaurants', NULL, NULL, NULL, 150, 'user:alice', 0, 'ref', 1732549690000);
```

**Index Usage:**

1. **EAVTO/AEVTO/AVETO** (text-based) - Used for exact value lookups
2. **VAETO** (text-based) - Used for backlink queries (who references this entity?)
3. **idx_a_number** - Used for numeric range queries (`amount > 100`)
4. **idx_a_integer** - Used for integer range queries (`age >= 18`)
5. **idx_a_datetime** - Used for temporal queries (`createdAt >= X AND createdAt < Y`)

**Benefits:**

✅ **Immutable fact store** - Append-only architecture inspired by event sourcing patterns
✅ **Time-travel queries** - Query any historical state with `tx <= N`
✅ **Audit trail** - Never lose data, complete provenance tracking
✅ **Multi-source truth** - Multiple origins can assert facts simultaneously
✅ **Efficient queries** - Four indices cover all access patterns
✅ **Simple implementation** - Plain SQLite, no complex dependencies
✅ **Git-friendly** - SQLite file can be versioned and diffed

---

### Ontology Import Strategy

**Base vocabularies imported with `origin: "core"`:**

```
Layer 1: RDF/RDFS/OWL Meta-Ontology
  ├─ core-ontology/rdf-rdfs-owl-core.ttl
  │  Defines: rdf:type, rdfs:Class, owl:ObjectProperty, xsd:string, etc.
  │  Purpose: Primitives for user-defined classes and properties
  │
Layer 2: BFO (Basic Formal Ontology)
  ├─ core-ontology/bfo.owl
  │  Defines: BFO:Entity, BFO:Continuant, BFO:Process, etc.
  │  Purpose: Upper ontology categories
  │
Layer 3: Common Core Ontologies
  ├─ core-ontology/CommonCoreOntologies-2.0-2024-11-06/src/cco-merged/
  │  Defines: CCO:Agent, CCO:Person, CCO:Organization, CCO:Act, etc.
  │  Purpose: Domain-specific extensions of BFO
  │
Layer 4: SuperNOVA Domain Ontology
  ├─ Defined by application or user
  │  Examples: Transaction, Category, Account
  │  Purpose: Application-specific classes
```

**Import Order:**

1. **RDF/RDFS/OWL** (tx: 1-100) - Meta-vocabulary
2. **BFO** (tx: 101-500) - Upper ontology
3. **CCO** (tx: 501-5000) - Domain ontologies
4. **SuperNOVA** (tx: 5001+) - Application classes

**Why import RDF/RDFS/OWL?**

Without these definitions in the database:
- ❌ User creates `owl:ObjectProperty` → system doesn't know what that is
- ❌ UI can't show available property types
- ❌ No validation that `rdfs:domain` requires a class as value
- ❌ Inference engine can't understand property characteristics

With these definitions:
- ✅ User creates property → system validates it's a known type
- ✅ UI shows dropdown: ObjectProperty, DatatypeProperty, etc.
- ✅ System knows `owl:TransitiveProperty` inherits from `owl:ObjectProperty`
- ✅ Inference: if `rdfs:domain` points to `Transaction`, validate instances

**Example facts from meta-ontology import:**

```sql
-- Define owl:ObjectProperty class
fact(e: "owl:ObjectProperty", a: "rdf:type", v: "rdfs:Class", tx: 1, origin: "core")
fact(e: "owl:ObjectProperty", a: "rdfs:subClassOf", v: "rdf:Property", tx: 1, origin: "core")
fact(e: "owl:ObjectProperty", a: "rdfs:label", v: "ObjectProperty", tx: 1, origin: "core")
fact(e: "owl:ObjectProperty", a: "rdfs:comment", v: "The class of object properties.", tx: 1, origin: "core")

-- Define rdfs:domain property
fact(e: "rdfs:domain", a: "rdf:type", v: "rdf:Property", tx: 2, origin: "core")
fact(e: "rdfs:domain", a: "rdfs:label", v: "domain", tx: 2, origin: "core")
fact(e: "rdfs:domain", a: "rdfs:domain", v: "rdf:Property", tx: 2, origin: "core")
fact(e: "rdfs:domain", a: "rdfs:range", v: "rdfs:Class", tx: 2, origin: "core")
```

**User creating a new property (uses imported vocabulary):**

```sql
-- User defines "hasCategory" property using owl:ObjectProperty
INSERT INTO transactions (origin, created_at) VALUES ('user:alice', 1732547890000);
-- Returns tx: 10000

INSERT INTO facts (e, a, v, tx, origin, retracted, v_type, created_at) VALUES
  ('hasCategory', 'rdf:type', 'owl:ObjectProperty', 10000, 'user:alice', 0, 'ref', 1732547890000),
  ('hasCategory', 'rdfs:label', 'has category', 10000, 'user:alice', 0, 'string', 1732547890000),
  ('hasCategory', 'rdfs:domain', 'Transaction', 10000, 'user:alice', 0, 'ref', 1732547890000),
  ('hasCategory', 'rdfs:range', 'Category', 10000, 'user:alice', 0, 'ref', 1732547890000);

-- System can now validate:
-- ✅ owl:ObjectProperty exists (from tx: 1)
-- ✅ rdfs:domain and rdfs:range are valid properties
-- ✅ Transaction and Category must be classes
```

